http://www.obdev.at/avrusb/.
http://www.obdev.at/products/avrusb/benefits.html

Этот пакет содержит ПО драйвера для интерфейса USB, находящегося на стороне устройства AVR, код библиотеки для устройства и хоста и полнофункциональные примеры для устройства и хоста:
  usbdrv .................. AVR-USB firmware, которое нужно включить в Ваш проект.
  examples ................ Код примера для устройства и хоста.
  libs-device ............. Заготовки кода firmware для устройства USB.
  libs-host ............... Заготовки кода для драйвера устройства.
  circuits ................ Схемы.
  Changelog.txt ........... Изменения от версии к версии.
  License.txt ............. Free Open Source license для этого пакета (GPL).
  CommercialLicense.txt ... Альтернативная коммерческая лицензия для этого пакета.
  USBID-License.txt ....... Лицензионные условия для свободных пар USB VID/PID.

Каждая папка содержит отдельный файл Readme, содержащий сведения о контенте.


ПРЕДВАРИТЕЛЬНЫЕ ТРЕБОВАНИЯ
==========================
Код для AVR-USB написан на C и ассемблере. Вам нужен либо avr-gcc, либо IAR CC для компилирования проекта. Мы рекомендуем avr-gcc, потому что он поставляется под свободной лицензией и легкодоступен. Gcc версии 3 генерирует для проекта AVR-USB немного более эффективный код, чем версия 4. Не все релизы протестированы с компилятором IAR. Ранние версии были протестированы с IAR 4.10B/W32 и 4.12A/W32 на ATmega8 с моделями памяти "small" и "tiny".

Пакет avr-gcc доступен для многих операционных систем:
  * Windows: WinAVR http://winavr.sourceforge.net/
  * Mac: AVRMacPack http://www.obdev.at/avrmacpack/
  * Linux и другие Unix-системы обычно имеют дополнительные пакеты разработки ПО для AVR. Если нет, следуйте инструкциям на http://www.nongnu.org/avr-libc/user-manual/install_tools.html

Наши примеры для стороны хоста скомпилированы с gcc на всех платформах. Gcc является компилятором по умолчанию для C на Mac, Linux и многих других Unix-систем. На windows мы рекомендуем MinGW (http://www.mingw.org/). Используйте автоматизированный MinGW installer, и проблем будет меньше всего. Вам также понадобится MSYS с того же сайта для работы со стандартными файлами Makefile.

Большая часть примеров также зависит от библиотеки libusb. Libusb доступна на http://libusb.sourceforge.net/ для Unix и http://libusb-win32.sourceforge.net/ для Windows.


ТЕХНИЧЕСКАЯ ДОКУМЕНТАЦИЯ
========================
Документация по API драйвера находится в usbdrv/usbdrv.h.
Документация для библиотек хоста и устройства находится в соответствующих заголовочных файлах. Для большей информации см. wiki на http://www.obdev.at/goto.php?t=avrusb-wiki.


ЛИЦЕНЗИЯ
========
AVR-USB и связанный с ней код распространяется под действием лицензии GNU General
Public License (GPL) версии 2 (см. License.txt). В дополнение к условиям GPL, мы очень поддерживаем публикацию Вашего полного проекта и посылку письма в OBJECTIVE DEVELOPMENT с ссылкой на Вашу публикацию.

Как альтенативу мы предлагаем коммерческую лицензию без ограничений GPL, см. CommercialLicense.txt.

ПРИМЕЧАНИЕ ПЕРЕВОДЧИКА
======================
Некоторые термины USB остались непереведенными для того, чтобы максимально донести смысл оригинала (иногда англоязычные термины добавлены в скобках). Также не переведены англоязычные имена авторов.
Непереведенные термины:
endpoint	== конечная точка
token       == токен, символ
firmware	== программное обеспечение, прошиваемое в микроконтроллер
GNU GENERAL PUBLIC LICENSE	== свободная лицензия на распространие ПО и другой интеллектуальной собственности
stuffed bit	== неинформационный бит в последовательности бит, см. http://en.wikipedia.org/wiki/Bit_stuffing
bitstuff	== вставка неинформационных бит, см. ссылку выше
msb			== most  significant bit (старший бит)
lsb			== least significant bit (младший бит)
leap		== прыжок, скачок (относится к командам перехода программы)
jmp			== переход на нужную инструкцию программы (в ассемблерном коде)
unstuffing  == точно не понял, что означает, но наверное - раскрытие, распознание последовательно приходящих бит
carry		== перенос, обычно означает флажок признака переноса процессора
C           == по контексту то же, что и carry. Иногда также означает язык Си.
zero		== нуль, обычно означает флажок признака нуля процессора
low			== низкий  логический уровень
high		== высокий логический уровень
generic		== обычный, стандартный
feature		== возможность, особенность, опция
backend		== скрытые от пользователя возможности программы (драйвера) или программного интерфейса
wildcard	== обусловленная маска для совпадения (например *, ? или 0)
BCD			== Binary Coded Decimal - кодирование десятичных чисел, где каждая цифра представлена отдельной последовательностью из 4 бит. См. http://en.wikipedia.org/wiki/Binary-coded_decimal.
front end	== frontend, "лицо" чего-нибудь, обычно в контексте ПО понимается интерфейс программы.
default		== по умолчанию
Eye candy 	== визуальный эффект от внешнего вида (программы)
hardware	== аппаратное обеспечение, железо
config		== конфигурация
watchdog	== сторожевой таймер, выводящий микроконтроллер из сна или зависания
JTAG		== специальная шина, управляющая микроконтроллером в режиме отладки программы
debug wire	== DebugWire, однопроводнОй JTAG-интерфейс
LED			== Light Emission Diode, светодиод
dummy		== пустой код или данные, которые либо ничего специально не значат, либо указаны для примера, либо для резервирования места
opaque		== непрозрачный, темный. В нашем контексте (данные дескриптора) означает данные, которые можно интерпретировать только с помощью программного интерфейса.
interrupt	== прерывание

----------------------------------------------------------------------------
(c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH.
http://www.obdev.at/
Перевод http://microsin.ru/
