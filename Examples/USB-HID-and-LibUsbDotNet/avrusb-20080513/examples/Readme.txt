custom-class
  Заказной (custom) класс устройства с ПО на хосте, основанном на libusb. Это демонстрирует прямой путь отправки малых порций данных к устройству и прием данных от устройства. Это НЕ демонстрирует, как посылать большие объемы данных на устройство или как принимать данные, сгенерированные устройством на лету (как использовать usbFunctionWrite() и usbFunctionRead()). См. hid-data как пример использования usbFunctionWrite() и usbFunctionRead().

hid-custom-rq
  Этот пример реализует ту же самую функциональность, что и пример custom-class, однако декларирует устройство как HID. Это предотвращает в Windows появление диалога "give me a driver CD". Устройство может так же управляться через libusb, как в предыдущем примере (на Windows должна быть установлена filter-версия libusb-win32). В дополнение к возможностям, представленным в custom-class, этот пример демонстрирует, как задается устройство HID-класса.

hid-mouse
  Это пример реализации устройства мыши. Драйвер для хоста не нужен, поскольку операционные системы на сегодняшний день have имеют встроенные драйверы для мышей USB. Это демонстрирует, как устройство HID-класса реально организуется во всем мире и как успользовать входящие конечные точки (interrupt-in endpoints).

hid-data
  Этот пример показывает, как HID-класс может быть злоупотреблен для передачи произвольных данных через HID feature report-ы. Эта техника имеет большое значение в Windows, поскольку не требуются DLL драйвера (пример hid-custom-rq требует libusb-win32 DLL, несмотря на то, что он может быть в жиректории программы). Приложение на стороне хоста не требует инсталляции, оно может просто запускаться даже с CD. Этот пример также демонстрирует как перемещать данные с использованием функций usbFunctionWrite() и usbFunctionRead().

usbtool
  Это инструмент разработки и отладки общего назначения для USB устройств. Вы можете использовать его во время разработки Ваших устройств для проверки различных запросов без других специальных тестовых программ. Однако это также пример использования функций из libusb API.

Больше информации можно почерпнуть по каждому примеру в файле Readme, расположенном в соответствующей директории.

Зависимости кода от аппаратного обеспечения AVR сведены к минимуму. Все примеры должны работать на любом чипе AVR, на котором есть некоторое количество ресурсов для запуска драйвера. Makefile и usbconfig.h сконфигурированы для metaboard hardware (см. http://www.obdev.at/goto.php?t=metaboard). Отредактируйте целевой чип, значения fuse, частоту тактов (clock rate) и программатор в Makefile и ножки I/O, выделенные для USB в usbconfig.h.


ЧТО НЕ ДЕМОНСТРИРУЕТСЯ В ЭТИХ ПРИМЕРАХ?
=======================================
Эти примеры показывают только базовую функциональность. Более сложные примеры и приложения реального мира показывают больше возможностей драйвера. Они доступны на http://www.obdev.at/avrusb/projects.html. Большинство этих возможностей описаны в нашей wiki-документации на http://www.obdev.at/goto.php?t=avrusb-wiki.

Можно упомянуть немного об:

Использование генераторов RC для системных тактов микроконтроллера
  Модуль 16.5 MHz AVR-USB разработан с учетом девиации тактовой частоты до 1%. Это позволяет использовать генератор RC. Поскольку RC-генератор AVR имеет заводскую точность только 10%, он должен быть откалиброван по внешнему точному источнику частоты. Пример EasyLogger показывает, как это сделать.

Динамически генерируемые дескрипторы
  Иногда Вам понадобится реализовать различные типы устройств USB в зависимости от перемычек или других условий. AVR-USB имеет очень гибкий интерфейс для обеспечения дескрипторов USB. См. AVR-Doper как обеспечивать дескрипторы во время выполнения программы (runtime).

Виртуальный COM-порт
  Нектотрые люди выбирают виртуальный последовательный инртерфейс для обмена со своими устройствами. Мы очень отговариваем от такого метода, поскольку он делает кое-что запрещенное спецификацией USB. Если Вы все-таки хотите идти этой дорогой, см. AVR-CDC.

Реализация режима приостановки (suspend mode)
  AVR-USB не реализует suspend mode. Это означает, что устройство не экономит потребляемую мощность, когда хост переводится в режим сна (sleep mode). Однако есть свободное firmware, реализующее suspend mode. См. USB2LPT для примера.

Ранее упомянутые примеры можно найти на 
    http://www.obdev.at/avrusb/prjall.html

----------------------------------------------------------------------------
(c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH.
http://www.obdev.at/
Перевод http://microsin.ru/
