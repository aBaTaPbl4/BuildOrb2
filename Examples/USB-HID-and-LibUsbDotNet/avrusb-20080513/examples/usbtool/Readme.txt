Это файл Readme для программы хоста usbtool, которая является утилитой командной строки общего назначения для посылки запросов USB произвольным устройствам. Usbtool базируется на библиотеке libusb.


ДЛЯ ЧЕГО ХОРОША USBTOOL?
========================
Когда Вы реализуете протокол связи наподобие USB, Вы должны обычно написать 2 программы, по одной на каждом конце коммуникации. Для USB это означает, что Вы должны написать firmware для устройства USB и программу драйвера для хоста.

Usbtool может съэкономить Ваши силы по написанию программы для хоста, как минимум на время разработки и тестирования firmware. Usbtool может посылать управляющие запросы control-in и -out на любые устройства и отправлять/получать данные через конечные точки interrupt и bulk.

Usbtool не только полезная утилита разработчика, она также является хорошим примером использования libusb для связи с USB-устройствами.


СИНОПСИС
========
  usbtool [ОПЦИИ] <КОМАНДЫ>


КОМАНДЫ
========
  list
    Эта команда печатает список устройств, найденных на всех доступных шинах USB. Опции -v, -V, -p и -P могут использоваться для фильтрации списка.

  control in|out <type> <recipient> <request> <value> <index>
    Посылает на устройство запрос control-in или control-out. Параметры запроса следующие:
      type ........ тип запроса, может быть "standard", "class", "vendor" или
                    "reserved". Тип определяет, какой модуль ПО в устройстве
                    обрабатывает ответ на запрос:
                    Standard - на запросы отвечает драйвер, class - запросы 
                    обрабатываются как результат реализации класса (например HID, CDC) и
                    vendor обрабатываются по коду пользователя (custom code).
      recipient ... получатель запроса в устройстве. Может быть "device",
                    "interface", "endpoint" или "other". Для запросов standard и
                    class в спецификации задается получатель для каждого запроса. 
                    Для запросов vendor выберите какой угодно ожидаемый код.
      request ..... 8-битная величина, идентифицирующая запрос.
      value ....... 16-битная величина, передаваемая в устройство.
      index ....... другая 16-битная величина, передаваемая в устройство.
    Используйте опции -v, -V, -p и -P для одиночного вывода в отдельное устройство. Используйте опции -d или -D для отправки данных в запрос OUT. Используйте опции -n, -O и -b для определения, что делать с данными, полученными в запросе IN.

  interrupt in|out
    Отправляет или принимает данные на interrupt-out resp. -in конечной точки. Используйте опции -v, -V, -p и -P для одиночного вывода в отдельное устройство. Используйте опции -d или -D для отправки данных в конечную точку OUT. Используйте опции -n, -O и -b для определения, что делать с данными, полученными от конечной точки IN.
    Используйте опцию -e для установки номера конечной точки, -c для выбора конфигурации, -i для требования особого интерфейса.

  bulk in|out
    То же самое, что и "interrupt in"/"interrupt out", только для конечных точек bulk.


ОПЦИИ
=====
Большая часть опций уже упомянута с использующими их командами. Здесь приведен полный список опций:

  -h или -?
    Выводит короткую подсказку.

  -v <vendor-id>
    Числовой vendor ID, можно использовать "*" для разрешения любого VID. Примите во внимание только устройства с подходящим vendor ID.

  -p <product-id>
    Цифровой product ID, можно использовать "*" для разрешения любого PID. Примите во внимание только устройства с подходящим product ID.

  -V <vendor-name-pattern>
    Маска соответствия для имени вендора (vendor name) в стиле shell. Примите во внимание только устройства с именем, которое соответствует маске vendor name.

  -P <product-name-pattern>
    Маска соответствия для имени продукта (product name) в стиле shell. Примите во внимание только устройства с именем, которое соответствует маске product name.

  -S <serial-pattern>
    Маска соответствия для серийного номера (serial number) в стиле shell. Примите во внимание только устройства с серийным номером, который соответствует маске serial number.

  -d <databytes>
    Байты данных для отправки на устройство в виде списка цифровых величин, разделенных запятыми. Пример: "1,2,3,4,5".

  -D <file>
    Двоичные данные для отправки на устройство могут быть взяты из файла file.

  -O <file>
    Записать принятые данные в предложенный файл file. Формат либо hex, либо двоичный, в зависимости от флага -b. По умолчанию принятые данные печатаются в стандартный вывод (консоль, откуда запущена программа).

  -b
    Устанавливает двоичный формат вывода для файлов и стандартного вывода. По умолчанию включен шестнадцатиричный (hex) листинг.

  -n <count>
    Числовая величина: максимальное количество байт для приема. Эта величина передается напрямую в функции API библиотеки libusb.

  -e <endpoint>
    Числовая величина: номер конечной точки для команд interrupt и bulk.

  -t <timeout>
    Числовая величина: таймаут в милисекундах для запроса. Эта величина передается напрямую в функции API библиотеки libusb.

  -c <configuration>
    Числовая величина: конечные точки interrupt и bulk обычно могут использоваться только тогда, когда выбраны конфигурация и интерфейс. Используйте -c и -i для указания величин конфигурации и интерфейса.

  -i <interface>
    Числовая величина: конечные точки interrupt и bulk обычно могут использоваться только тогда, когда выбраны конфигурация и интерфейс. Используйте -c и -i для указания величин конфигурации и интерфейса.

  -w
    Usbtool может быть слишком многословной для некоторых приложений. Используйте эту опцию для подавления предупреждений USB (USB warnings).


ЧИСЛОВЫЕ ВЕЛИЧИНЫ
=================
Все цифровые ввеличины могут быть указаны в шестнадцатиричном (hex), десятичном (decimal) или восьмиричном (octal) формате. Hex величины идентифицируются префиксом 0x или 0X, octal идентифицируются лидирующим нулем "0" (цифра ноль). Десятичные числа начинаются с ненулевой цифры. Допустим дополнительный символ знака. Специальная величина "*" транслируется в ноль и воспринимается в некоторых контекстах как "любое число".


МАСКИ В СТИЛЕ SHELL
===================
Некоторые опции принимают маски в стиле shell в качестве аргумента. Это относится к Unix shell и их операциям wildcard с файлами:
  + "*" (символ звездочки) соответствует любому числу (от 0 до бесконечности) и любых символов.
  + "?" соответствует ровно одному произвольному символу.
  + список символов в квадратных скобках (например "[abc]") соответствует любому символу из списка. Если дефис ("-") присутствует в списке, он должен быть первым или последним символом. Если в списке есть знак вставки (caret, "^"), он не должен быть первым в списке. Закрывающая квадратная скобка ("]") не должна быть первым символом в списке. Диапазон символов может быть указан методом "[a-z]". Это соответствует всем символам с кодами ASCII начиная с "a" и оканчивая "z". Вся конструкция "[a-z]" соответсвует только одному символу из диапазона.
  + список символов в квадратных скобках, начинающийся с знака вставки (caret, "^"), например "[^abc]", соответствует любому символу, которого нет в этом списке. Другие правила работают также, как вышеуказанные.
  + обратный слеш "\" (backslash), за которым следует любой символ, соответствует этому символу. Это целесообразно использовать для указания "*", "?", "[" and "\" в качестве обычных символов.


СБОРКА USBTOOL
==============
Usbtool использует libusb на Unix и libusb-win32 на Windows. Эти библиотеки могут быть получены со ссылок http://libusb.sourceforge.net/ и http://libusb-win32.sourceforge.net/ соответственно. На Unix простой ввод команды "make" должен компилировать исходники (хотя Вы можете отредактировать Makefile для включения или исключения дополнительных библиотек). На Windows мы рекомендуем использовать MinGW и MSYS. См. файл Readme на верхнем уровне пакета, где это описано более подробно. Отредактируйте Makefile.windows для соответствия путям инсталляции до вашей библитеки libusb-win32, и запускайте сборку командой "make -f Makefile.windows".


ПРИМЕРЫ
=======
Получить список всех устройств USB, подключенных к Вашему компьютеру:
    usbtool -w list
VID=0x046d PID=0xc03e vendor="Logitech" product="USB-PS/2 Optical Mouse"
VID=0x13fe PID=0x1a00 vendor="Kingston" product="DataTraveler 2.0" serial="5B69148D4BF1"

Для проверки, соответствует ли опция выбора небоходимому устройству, используйте eg.
    usbtool -w -P "DataTraveler 2.0" list
VID=0x13fe PID=0x1a00 vendor="Kingston" product="DataTraveler 2.0" serial="5B69148D4BF1"

    usbtool -w -P LEDControl list 
Эта команда показывает все подключенные устройства LEDControl, либо ничего не выводит, если устройства LEDControl не найдены. LEDControl является устройством из примера "custom-class".

Вы также можете посылать команды LEDControl, используя usbtool. Из файла requests.h, находящегося в папке examples/custom-class/firmware, мы можем узнать, что запрос set-status имеет числовую величину 1 и запрос get-status величину 2. См. этот файл для деталей по используемому протокулу. Таким образом, мы можем опросить статус светодиода:

    usbtool -w -P LEDControl control in vendor device 2 0 0

Эта команда напечатает 0x00, если LED погашен, или 0x01, если горит. Для включения LED введите:

    usbtool -w -P LEDControl control out vendor device 1 1 0

и для выключения:

    usbtool -w -P LEDControl control out vendor device 1 0 0


----------------------------------------------------------------------------
(c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH.
http://www.obdev.at/
Перевод http://microsin.ru/
